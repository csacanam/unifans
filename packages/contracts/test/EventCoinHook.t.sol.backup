// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test} from "forge-std/Test.sol";
import {Deployers} from "@uniswap/v4-core/test/utils/Deployers.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {Currency} from "v4-core/types/Currency.sol";
import {EventCoinHook} from "../src/EventCoinHook.sol";
import {EventToken} from "../src/EventToken.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";
import {console} from "forge-std/console.sol";

/**
 * @title EventCoinHookTest
 * @dev Test suite for EventCoinHook contract - step by step validation
 */
contract EventCoinHookTest is Test, Deployers {
    EventCoinHook hook;
    EventToken eventToken;

    // Pool currencies
    Currency eventTokenCurrency;
    Currency wethCurrency;

    // Test parameters
    string public constant EVENT_NAME = "UniFans Test Event";
    string public constant TOKEN_SYMBOL = "TEST";
    uint256 public constant EVENT_DATE = 1758577019; // 30 days from now
    address public constant ORGANIZER = address(0x123);
    address public constant PROTOCOL_WALLET = address(0x456);

    function setUp() public {
        // Deploy v4 core contracts
        deployFreshManagerAndRouters();

        // Deploy EventToken
        eventToken = new EventToken(
            EVENT_NAME,
            TOKEN_SYMBOL,
            EVENT_DATE,
            ORGANIZER
        );

        console.log("EventToken deployed successfully");
        console.log("EventToken address:", address(eventToken));
        console.log("Organizer:", ORGANIZER);

        // Configure currencies (ETH is always currency0, EventToken is currency1)
        wethCurrency = Currency.wrap(address(0));
        eventTokenCurrency = Currency.wrap(address(eventToken));

        console.log("Currencies configured");
        console.log("WETH currency:", address(0));
        console.log("EventToken currency:", address(eventToken));

        // Deploy hook with proper Uniswap V4 flags
        uint160 flags = uint160(
            Hooks.AFTER_INITIALIZE_FLAG | Hooks.AFTER_SWAP_FLAG
        );
        address hookAddress = address(flags);

        console.log("Hook flags calculated");
        console.log("Hook flags:", flags);
        console.log("Hook address:", hookAddress);

        // Deploy hook with proper flags
        deployCodeTo(
            "EventCoinHook.sol",
            abi.encode(
                manager,
                ORGANIZER,
                address(eventToken),
                PROTOCOL_WALLET
            ),
            hookAddress
        );

        hook = EventCoinHook(payable(hookAddress));
        console.log("Hook deployed successfully");
        console.log("Hook address:", address(hook));

        // Verify hook deployment
        console.log("Verifying hook deployment...");
        assertEq(hook.eventOrganizer(), ORGANIZER, "Organizer mismatch");
        assertEq(hook.eventToken(), address(eventToken), "EventToken mismatch");
        assertEq(
            hook.protocolWallet(),
            PROTOCOL_WALLET,
            "ProtocolWallet mismatch"
        );
        console.log("Hook deployment verified");

        // Transfer tokens to hook
        console.log("Transferring tokens to hook...");
        uint256 contractBalance = eventToken.balanceOf(address(eventToken));
        console.log(
            "Contract balance before setHook:",
            contractBalance / 1e18,
            "tokens"
        );

        eventToken.setHook(address(hook));

        uint256 hookBalance = eventToken.balanceOf(address(hook));
        uint256 contractBalanceAfter = eventToken.balanceOf(
            address(eventToken)
        );

        console.log("setHook completed");
        console.log(
            "Hook balance after setHook:",
            hookBalance / 1e18,
            "tokens"
        );
        console.log(
            "Contract balance after setHook:",
            contractBalanceAfter / 1e18,
            "tokens"
        );

        // Verify token transfer
        assertTrue(
            hookBalance >= 600_000_000 ether,
            "Hook should have 600M tokens"
        );
        assertTrue(
            contractBalanceAfter == 0,
            "Contract should be empty after setHook"
        );
        console.log("Token transfer verified");

        // Test hook permissions before pool initialization
        console.log("Testing hook permissions...");
        Hooks.Permissions memory permissions = hook.getHookPermissions();
        assertTrue(
            permissions.afterInitialize,
            "afterInitialize should be true"
        );
        assertTrue(permissions.afterSwap, "afterSwap should be true");
        console.log("Hook permissions verified");
    }

    function test_basicSetup() public {
        // This test validates the basic setup without pool initialization
        console.log("Basic setup test passed");
        console.log(
            "Hook has",
            eventToken.balanceOf(address(hook)) / 1e18,
            "tokens"
        );
        console.log("Ready for pool initialization");
    }

    function test_poolInitialization() public {
        // This test will initialize the pool and validate afterInitialize
        console.log("Starting pool initialization...");

        try this.initPoolWithHook() {
            console.log("Pool initialization successful");
        } catch Error(string memory reason) {
            console.log("Pool initialization failed with reason:", reason);
            revert(reason);
        } catch (bytes memory lowLevelData) {
            console.log("Pool initialization failed with low level error");
            revert("Pool initialization failed");
        }
    }

    function initPoolWithHook() external {
        // Initialize pool with the hook
        (key, ) = initPool(
            wethCurrency,
            eventTokenCurrency,
            hook,
            3000,
            SQRT_PRICE_1_1
        );

        console.log("Pool initialized successfully");
        console.log(
            "Pool key currency0 (ETH):",
            Currency.unwrap(key.currency0)
        );
        console.log(
            "Pool key currency1 (Token):",
            Currency.unwrap(key.currency1)
        );
        console.log("Pool key hooks:", address(key.hooks));

        // Verify pool was initialized with the hook
        assertTrue(
            address(key.hooks) == address(hook),
            "Pool should use our hook"
        );
        console.log("Pool hook verification passed");

        // Check if afterInitialize was executed
        uint256 hookBalanceAfter = eventToken.balanceOf(address(hook));
        console.log(
            "Hook balance after pool init:",
            hookBalanceAfter / 1e18,
            "tokens"
        );

        // If afterInitialize worked, the hook should have fewer tokens (they were added to the pool)
        if (hookBalanceAfter < 600_000_000 ether) {
            console.log("afterInitialize executed - tokens were added to pool");
            console.log(
                "Tokens moved to pool:",
                (600_000_000 ether - hookBalanceAfter) / 1e18,
                "tokens"
            );
        } else {
            console.log(
                "afterInitialize may not have executed - hook still has all tokens"
            );
        }
    }
}
